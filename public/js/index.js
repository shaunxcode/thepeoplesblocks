// Generated by CoffeeScript 1.3.3
(function() {
  var addTile, count, displayHeight, displayWidth, gridLayer, gridPos, height, p, piece, r, rotations, stage, tileImages, tilePieces, tileSize, tilesLayer, width, x, y, _fn, _i, _j, _k, _len, _ref;

  tileSize = 50;

  width = 8;

  height = 8;

  displayHeight = tileSize * width;

  displayWidth = tileSize * height;

  stage = new Kinetic.Stage({
    container: 'world',
    width: displayWidth,
    height: displayHeight + 80
  });

  gridPos = function(evt) {
    return {
      x: Math.floor(evt.pageX / tileSize),
      y: Math.floor(evt.pageY / tileSize)
    };
  };

  gridLayer = new Kinetic.Layer;

  for (x = _i = 0; 0 <= displayWidth ? _i <= displayWidth : _i >= displayWidth; x = _i += tileSize) {
    gridLayer.add(new Kinetic.Line({
      points: [x - 0.5, 0, x - 0.5, displayHeight],
      stroke: "black",
      strokeWidth: 1
    }));
  }

  for (y = _j = 0; 0 <= displayHeight ? _j <= displayHeight : _j >= displayHeight; y = _j += tileSize) {
    gridLayer.add(new Kinetic.Line({
      points: [0, y - 0.5, displayWidth, y - 0.5],
      stroke: "black",
      strokeWidth: 1
    }));
  }

  stage.add(gridLayer);

  tilesLayer = new Kinetic.Layer;

  stage.add(tilesLayer);

  addTile = function(piece, pos) {
    var tile;
    tilesLayer.add(tile = new Kinetic.Image({
      image: tileImages[piece],
      x: pos.x * tileSize,
      y: pos.y * tileSize,
      width: 50,
      height: 50,
      draggable: true,
      dragBoundFunc: function(pos) {
        return {
          x: (pos.x < 0 ? 0 : pos.x),
          y: (pos.y < 0 ? 0 : pos.y)
        };
      }
    }));
    tilesLayer.draw();
    tile.on("dragend", function(evt) {
      pos = gridPos(evt);
      tile.setX(pos.x * tileSize);
      tile.setY(pos.y * tileSize);
      return tilesLayer.draw();
    });
    tile.on("mouseover", function() {
      return document.body.style.cursor = 'pointer';
    });
    return tile.on("mouseout", function() {
      return document.body.style.cursor = 'default';
    });
  };

  tileImages = {};

  tilePieces = {};

  count = 0;

  _ref = {
    straight: [0, 90],
    corner: [270, 0, 90, 180],
    intersection: [0]
  };
  for (p in _ref) {
    rotations = _ref[p];
    _fn = function(piece, ogx, ogy) {
      var placeHolder;
      tileImages[piece] = new Image;
      tilesLayer.add(placeHolder = new Kinetic.Image({
        x: ogx,
        y: ogy,
        width: tileSize,
        height: tileSize
      }));
      tileImages[piece].onload = function() {
        placeHolder.setImage(tileImages[piece]);
        tilesLayer.add(tilePieces[piece] = placeHolder.clone());
        placeHolder.applyFilter(Kinetic.Filters.Grayscale, null, function() {
          return tilesLayer.draw();
        });
        tilePieces[piece].setDraggable(true);
        tilePieces[piece].on("dragend", function(evt) {
          tilePieces[piece].setX(ogx);
          tilePieces[piece].setY(ogy);
          return addTile(piece, gridPos(evt));
        });
        tilePieces[piece].on("mouseover", function() {
          return document.body.style.cursor = 'pointer';
        });
        return tilePieces[piece].on("mouseout", function() {
          return document.body.style.cursor = 'default';
        });
      };
      tileImages[piece].src = "images/" + piece + ".png";
      return count++;
    };
    for (_k = 0, _len = rotations.length; _k < _len; _k++) {
      r = rotations[_k];
      piece = piece = "" + p + "-" + r;
      _fn(piece, count * tileSize, height * tileSize);
    }
  }

}).call(this);
