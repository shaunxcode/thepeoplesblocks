// Generated by CoffeeScript 1.3.3
(function() {
  var AnimationPath, CycNum, EAST, NORTH, SOUTH, WEST, addTile, calculateRoutes, cars, carsLayer, checkDir, checkTrackPos, corner0, corner180, corner270, corner90, count, displayHeight, displayWidth, drawGrid, fullTrack, gridLayer, gridPos, guiLayer, halfTrack, height, i, intersection0, light, loadFromHash, moveTrackStart, p, pathLayer, piece, pieceCodes, r, rotations, stage, startButton, startPoint, startTrain, stopTrain, straight0, straight90, t, tileImages, tilePieces, tileSize, tilesLayer, trackAcceptsFromDir, trackPath, trackPathSegs, trackStart, train, width, x, y, _checkTrack, _fn, _i, _j, _len, _ref, _ref1;

  tileSize = 50;

  width = 8;

  height = 8;

  displayHeight = tileSize * width;

  displayWidth = tileSize * height;

  trackStart = {
    x: 0,
    y: 0
  };

  tileImages = {};

  tilePieces = {};

  window.track = (function() {
    var _i, _results;
    _results = [];
    for (y = _i = 0; 0 <= height ? _i <= height : _i >= height; y = 0 <= height ? ++_i : --_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (x = _j = 0; 0 <= width ? _j <= width : _j >= width; x = 0 <= width ? ++_j : --_j) {
          _results1.push(false);
        }
        return _results1;
      })());
    }
    return _results;
  })();

  stage = new Kinetic.Stage({
    container: 'world',
    width: displayWidth + 80,
    height: displayHeight + 80
  });

  tilesLayer = new Kinetic.Layer;

  gridLayer = new Kinetic.Layer;

  pathLayer = new Kinetic.Layer;

  gridPos = function(evt) {
    return {
      x: Math.floor(evt.pageX / tileSize),
      y: Math.floor(evt.pageY / tileSize)
    };
  };

  drawGrid = function() {
    var _i, _j, _results;
    for (x = _i = 0; 0 <= displayWidth ? _i <= displayWidth : _i >= displayWidth; x = _i += tileSize) {
      gridLayer.add(new Kinetic.Line({
        points: [x - 0.5, 0, x - 0.5, displayHeight],
        stroke: "black",
        strokeWidth: 1
      }));
    }
    _results = [];
    for (y = _j = 0; 0 <= displayHeight ? _j <= displayHeight : _j >= displayHeight; y = _j += tileSize) {
      _results.push(gridLayer.add(new Kinetic.Line({
        points: [0, y - 0.5, displayWidth, y - 0.5],
        stroke: "black",
        strokeWidth: 1
      })));
    }
    return _results;
  };

  addTile = function(piece, pos) {
    var tile;
    track[pos.y][pos.x] = piece;
    tilesLayer.add(tile = new Kinetic.Image({
      image: tileImages[piece],
      x: pos.x * tileSize,
      y: pos.y * tileSize,
      width: 50,
      height: 50,
      draggable: true,
      dragBoundFunc: function(pos) {
        return {
          x: (pos.x < 0 ? 0 : pos.x),
          y: (pos.y < 0 ? 0 : pos.y)
        };
      }
    }));
    tilesLayer.draw();
    calculateRoutes();
    tile.on("dragend", function(evt) {
      var newPos;
      track[pos.y][pos.x] = false;
      newPos = gridPos(evt);
      track[newPos.y][newPos.x] = piece;
      pos = newPos;
      tile.setX(newPos.x * tileSize);
      tile.setY(newPos.y * tileSize);
      tilesLayer.draw();
      return calculateRoutes();
    });
    tile.on("mouseover", function() {
      return document.body.style.cursor = 'pointer';
    });
    return tile.on("mouseout", function() {
      return document.body.style.cursor = 'default';
    });
  };

  pieceCodes = ["straight-0", "straight-90", "corner-0", "corner-90", "corner-180", "corner-270", "intersection-0"];

  straight0 = pieceCodes[0], straight90 = pieceCodes[1], corner0 = pieceCodes[2], corner90 = pieceCodes[3], corner180 = pieceCodes[4], corner270 = pieceCodes[5], intersection0 = pieceCodes[6];

  _ref = ["north", "east", "south", "west"], NORTH = _ref[0], EAST = _ref[1], SOUTH = _ref[2], WEST = _ref[3];

  trackAcceptsFromDir = function(pos, fromDir) {
    var piece;
    piece = track[pos.y][pos.x];
    console.log("IS " + piece + " ok for " + fromDir);
    switch (fromDir) {
      case NORTH:
        return piece === straight0 || piece === corner0 || piece === corner90 || piece === intersection0;
      case SOUTH:
        return piece === straight0 || piece === corner180 || piece === corner270 || piece === intersection0;
      case EAST:
        return piece === straight90 || piece === corner90 || piece === corner180 || piece === intersection0;
      case WEST:
        return piece === straight90 || piece === corner0 || piece === corner270 || piece === intersection0;
    }
  };

  checkTrackPos = function(x, y) {
    if (track[y][x]) {
      return {
        x: x,
        y: y
      };
    }
  };

  _checkTrack = function(xd, yd, fromDir) {
    return function(pos) {
      var potentialPos;
      if (potentialPos = checkTrackPos(pos.x + xd, pos.y + yd)) {
        if (trackAcceptsFromDir(potentialPos, fromDir)) {
          console.log("ACCEPTED", potentialPos);
          return potentialPos;
        }
      }
    };
  };

  checkDir = {
    north: _checkTrack(0, -1, NORTH),
    south: _checkTrack(0, 1, SOUTH),
    east: _checkTrack(1, 0, EAST),
    west: _checkTrack(-1, 0, WEST)
  };

  fullTrack = tileSize;

  halfTrack = tileSize / 2;

  trackPath = false;

  trackPathSegs = false;

  calculateRoutes = function() {
    var col, dir, flatPath, next, path, pathPush, pos, pts, row, startDir, _i, _j, _k, _len, _len1, _len2;
    if (track[trackStart.y][trackStart.x]) {
      pos = trackStart;
    } else {
      for (y = _i = 0, _len = track.length; _i < _len; y = ++_i) {
        row = track[y];
        if (pos) {
          break;
        }
        for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
          col = row[x];
          if (col) {
            pos = {
              x: x,
              y: y
            };
            break;
          }
        }
      }
    }
    if (!pos) {
      return;
    }
    moveTrackStart(pos);
    path = [];
    pathPush = function(points) {
      var last;
      last = path[path.length - 1];
      if (last && last[0] === points[0][0] && last[1] === points[0][1]) {
        points.shift();
      }
      return path.push.apply(path, points);
    };
    startDir = dir = (function() {
      switch (track[pos.y][pos.x]) {
        case straight0:
          if (checkDir.south(pos)) {
            return SOUTH;
          } else {
            return NORTH;
          }
          break;
        case straight90:
          if (checkDir.east(pos)) {
            return EAST;
          } else {
            return WEST;
          }
          break;
        case corner0:
          if (checkDir.east(pos)) {
            return NORTH;
          } else {
            return EAST;
          }
          break;
        case corner90:
          if (checkDir.west(pos)) {
            return NORTH;
          } else {
            return WEST;
          }
          break;
        case corner180:
          if (checkDir.west(pos)) {
            return SOUTH;
          } else {
            return EAST;
          }
          break;
        case corner270:
          if (checkDir.east(pos)) {
            return SOUTH;
          } else {
            return WEST;
          }
          break;
        case intersection0:
          if (checkDir.east(pos)) {
            return EAST;
          } else if (checkDir.west(pos)) {
            return WEST;
          } else if (checkDir.north(pos)) {
            return NORTH;
          } else {
            return SOUTH;
          }
      }
    })();
    next = false;
    while (true) {
      x = pos.x * fullTrack;
      y = pos.y * fullTrack;
      console.log(pos, track[pos.y][pos.x], dir);
      switch (track[pos.y][pos.x]) {
        case straight0:
        case (dir === NORTH || dir === SOUTH) && intersection0:
          pts = [[x + halfTrack, y + fullTrack], [x + halfTrack, y]];
          if (dir === SOUTH) {
            pts.reverse();
          }
          break;
        case straight90:
        case (dir === EAST || dir === WEST) && intersection0:
          pts = [[x, y + halfTrack], [x + fullTrack, y + halfTrack]];
          if (dir === WEST) {
            pts.reverse();
          }
          break;
        case corner0:
          pts = [[x + halfTrack, y + fullTrack], [x + halfTrack, y + fullTrack - (halfTrack / 2)], [x + fullTrack - (halfTrack / 2), y + halfTrack], [x + fullTrack, y + halfTrack]];
          if (dir === NORTH) {
            dir = EAST;
          } else {
            dir = SOUTH;
            pts.reverse();
          }
          break;
        case corner90:
          pts = [[x + halfTrack, y + fullTrack], [x + halfTrack, y + fullTrack - (halfTrack / 2)], [x + (halfTrack / 2), y + halfTrack], [x, y + halfTrack]];
          if (dir === NORTH) {
            dir = WEST;
          } else {
            dir = SOUTH;
            pts.reverse();
          }
          break;
        case corner180:
          pts = [[x + halfTrack, y], [x + halfTrack, y + (halfTrack / 2)], [x + (halfTrack / 2), y + halfTrack], [x, y + halfTrack]];
          if (dir === SOUTH) {
            dir = WEST;
          } else {
            dir = NORTH;
            pts.reverse();
          }
          break;
        case corner270:
          pts = [[x + halfTrack, y], [x + halfTrack, y + (halfTrack / 2)], [x + fullTrack - (halfTrack / 2), y + halfTrack], [x + fullTrack, y + halfTrack]];
          if (dir === SOUTH) {
            dir = EAST;
          } else {
            dir = NORTH;
            pts.reverse();
          }
      }
      pathPush(pts);
      console.log("check direction", dir);
      next = checkDir[dir](pos);
      if (!next) {
        console.log("exhausted search");
        break;
      }
      if (next.x === trackStart.x && next.y === trackStart.y) {
        if (track[next.y][next.x] === intersection0) {
          console.log(dir, startDir);
          if (dir === startDir) {
            console.log("stop on intersection", dir, startDir);
            break;
          }
        } else {
          console.log("breaking because start is current");
          break;
        }
      }
      pos = next;
      next = false;
    }
    if (trackPath) {
      trackPath.remove();
    }
    if (path.length) {
      console.log(path);
      flatPath = [];
      for (_k = 0, _len2 = path.length; _k < _len2; _k++) {
        x = path[_k];
        flatPath.push(x[0], x[1]);
      }
      console.log(flatPath);
      pathLayer.add(trackPath = new Kinetic.Line({
        points: flatPath,
        stroke: "green",
        strokeWidth: 20,
        opacity: 0.5
      }));
      pathLayer.draw();
      return trackPathSegs = path;
    }
  };

  drawGrid();

  stage.add(pathLayer);

  stage.add(gridLayer);

  stage.add(tilesLayer);

  count = 0;

  _ref1 = {
    straight: [0, 90],
    corner: [270, 0, 90, 180],
    intersection: [0]
  };
  for (p in _ref1) {
    rotations = _ref1[p];
    _fn = function(piece, ogx, ogy) {
      var placeHolder;
      tileImages[piece] = new Image;
      tilesLayer.add(placeHolder = new Kinetic.Image({
        x: ogx,
        y: ogy,
        width: tileSize,
        height: tileSize
      }));
      tileImages[piece].onload = function() {
        placeHolder.setImage(tileImages[piece]);
        tilesLayer.add(tilePieces[piece] = placeHolder.clone());
        placeHolder.applyFilter(Kinetic.Filters.Grayscale, null, function() {
          return tilesLayer.draw();
        });
        tilePieces[piece].setDraggable(true);
        tilePieces[piece].on("dragend", function(evt) {
          tilePieces[piece].setX(ogx);
          tilePieces[piece].setY(ogy);
          return addTile(piece, gridPos(evt));
        });
        tilePieces[piece].on("mouseover", function() {
          return document.body.style.cursor = 'pointer';
        });
        return tilePieces[piece].on("mouseout", function() {
          return document.body.style.cursor = 'default';
        });
      };
      tileImages[piece].src = "images/" + piece + ".png";
      return count++;
    };
    for (_i = 0, _len = rotations.length; _i < _len; _i++) {
      r = rotations[_i];
      piece = piece = "" + p + "-" + r;
      _fn(piece, count * tileSize, height * tileSize);
    }
  }

  CycNum = {
    add: function(num, amt, min, max) {
      if (min == null) {
        min = 0;
      }
      if (max == null) {
        max = 1;
      }
      if ((num + amt) > max) {
        return min + ((num + amt) - max);
      } else {
        return num + amt;
      }
    },
    sub: function(num, amt, min, max) {
      if (min == null) {
        min = 0;
      }
      if (max == null) {
        max = 1;
      }
      if ((num - amt) < min) {
        return max - (amt - num);
      } else {
        return num - amt;
      }
    }
  };

  AnimationPath = function(pathSegs) {
    var i, pathString, seg, _j, _len1;
    this.path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathString = ["M" + (pathSegs[0].join(" "))];
    for (i = _j = 0, _len1 = pathSegs.length; _j < _len1; i = ++_j) {
      seg = pathSegs[i];
      if (i) {
        pathString.push("L" + (seg.join(" ")));
      }
    }
    this.path.setAttribute("d", pathString.join(" ") + "Z");
    return this.updatePath();
  };

  AnimationPath.prototype.updatePath = function() {
    return this.len = this.path.getTotalLength();
  };

  AnimationPath.prototype.pointAt = function(percent) {
    return this.path.getPointAtLength(this.len * percent);
  };

  AnimationPath.prototype.rotationAt = function(percent) {
    var p1, p2;
    p1 = this.pointAt(CycNum.sub(percent, 0.01));
    p2 = this.pointAt(CycNum.add(percent, 0.01));
    return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
  };

  AnimationPath.prototype.start = function(duration, callback, delay) {
    var startTime,
      _this = this;
    if (delay == null) {
      delay = 1 / 40;
    }
    startTime = new Date;
    return setInterval((function() {
      var elapsed, now, percent;
      now = new Date;
      elapsed = (now - startTime) / 1000;
      percent = elapsed / duration;
      if (percent >= 1) {
        percent = 1;
        startTime = now;
      }
      return callback(percent);
    }), delay * 1000);
  };

  /*
  segs = [[60, 100], [20, 200], [100, 300], [125, 305], [150, 310], [250, 250], [270, 230], [270, 175], [240, 105], [120, 30], [60, 50], [60, 100]]
  pts = []
  pts = pts.concat x for x in segs
  */


  carsLayer = new Kinetic.Layer;

  stage.add(carsLayer);

  carsLayer.add(train = new Kinetic.Rect({
    height: 30,
    offset: [15 / 2, 30 / 2],
    width: 15,
    stroke: "black",
    fill: "grey"
  }));

  carsLayer.add(light = new Kinetic.Polygon({
    points: [50, 25, 60, 25, 135, 100, -25, 100, 50, 25],
    fill: "yellow",
    stroke: "orange",
    opacity: 0.5,
    offset: [110 / 2, 10]
  }));

  cars = [train];

  for (i = _j = 0; _j <= 2; i = ++_j) {
    carsLayer.add(t = train.clone());
    cars.push(t);
  }

  startTrain = function() {
    var path, relPer, row, url, _k, _l, _len1, _len2;
    if (!trackPathSegs) {
      return;
    }
    url = [];
    for (y = _k = 0, _len1 = track.length; _k < _len1; y = ++_k) {
      row = track[y];
      for (x = _l = 0, _len2 = row.length; _l < _len2; x = ++_l) {
        p = row[x];
        if (p) {
          url.push("" + y + "." + x + "." + (_.indexOf(pieceCodes, p)));
        }
      }
    }
    window.location.hash = url.join("/");
    path = new AnimationPath(trackPathSegs);
    relPer = (train.getHeight() + 5) / path.len;
    carsLayer.show();
    console.log(path.len);
    return path.start(path.len / 85, function(percent) {
      var car, np, _len3, _m;
      for (i = _m = 0, _len3 = cars.length; _m < _len3; i = ++_m) {
        car = cars[i];
        np = CycNum.sub(percent, relPer * i);
        p = path.pointAt(np);
        r = path.rotationAt(np);
        car.setX(p.x);
        car.setY(p.y);
        car.setRotationDeg(r - 90);
        if (i === 0) {
          light.setX(p.x);
          light.setY(p.y);
          light.setRotationDeg(r - 90);
        }
      }
      return carsLayer.draw();
    });
  };

  stopTrain = function() {
    return carsLayer.hide();
  };

  stage.add(guiLayer = new Kinetic.Layer);

  guiLayer.add(startPoint = new Kinetic.Circle({
    radius: 10,
    fill: "green",
    stroke: "black",
    opacity: 0.9,
    draggable: true
  }));

  guiLayer.add(startButton = new Kinetic.Rect({
    x: width * tileSize + 10,
    y: 10,
    fill: "green",
    width: 25,
    height: 15
  }));

  startButton.on("click", function() {
    console.log("clicked");
    return startTrain();
  });

  startPoint.on("dragend", function(evt) {
    return moveTrackStart(gridPos(evt));
  });

  moveTrackStart = function(pos) {
    startPoint.setX((pos.x * tileSize) + (tileSize / 2));
    startPoint.setY((pos.y * tileSize) + (tileSize / 2));
    trackStart = pos;
    return guiLayer.draw();
  };

  moveTrackStart({
    x: 0,
    y: 0
  });

  loadFromHash = function() {
    var hash, part, _k, _len1, _ref2, _ref3, _results;
    if (hash = window.location.hash) {
      console.log(hash);
      _ref2 = hash.slice(1).split("/");
      _results = [];
      for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
        part = _ref2[_k];
        _ref3 = part.split("."), y = _ref3[0], x = _ref3[1], p = _ref3[2];
        if ((y != null) && (x != null) && (p != null)) {
          _results.push(addTile(pieceCodes[p], {
            x: x,
            y: y
          }));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  loadFromHash();

}).call(this);
